#!/usr/bin/env bash
# Usage: manage-worktree.sh <subcommand> [args]
# Manages plan-level worktree lifecycle (create, merge, list, cleanup-phase).
#
# Subcommands:
#   create <phase> <plan> <base-branch>              — Create worktree for a plan
#   merge  <phase> <plan> <base-branch> <merge-dir>  — Merge plan branch and remove worktree
#   cleanup-phase <workspace-dir> <branch>            — Switch workspace back to workspace-base, delete phase branch
#   list                                              — List active plan worktrees
#
# Requires: bare repo layout (.bare/) from setup-worktrees.sh
# Output: key=value pairs for machine parsing
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
READ_CONFIG="$SCRIPT_DIR/../../kata-configure-settings/scripts/read-config.sh"

# --- Resolve project root ---
# If running from inside a worktree (../.bare exists), cd to project root.
# All paths in this script are relative to the project root (parent of main/).
if [ ! -d .bare ] && [ -d ../.bare ]; then
  cd ..
fi

# --- Precondition Checks ---

check_preconditions() {
  # 1. Bare repo layout required
  if [ ! -d .bare ]; then
    echo "Error: Bare repo layout required. Run setup-worktrees.sh first." >&2
    exit 1
  fi

  # 2. worktree.enabled must be true
  local worktree_enabled
  worktree_enabled=$(bash "$READ_CONFIG" "worktree.enabled" "false")
  if [ "$worktree_enabled" != "true" ]; then
    echo "Error: worktree.enabled is false in config." >&2
    exit 1
  fi
}

# --- Subcommands ---

cmd_create() {
  local phase="${1:?Usage: manage-worktree.sh create <phase> <plan> <base-branch>}"
  local plan="${2:?Usage: manage-worktree.sh create <phase> <plan> <base-branch>}"
  local base_branch="${3:?Usage: manage-worktree.sh create <phase> <plan> <base-branch>}"

  local branch_name="plan/${phase}-${plan}"
  local worktree_path
  worktree_path="$(pwd)/plan-${phase}-${plan}"

  # Idempotent: if worktree already exists, print info and exit 0
  if [ -d "$worktree_path" ]; then
    echo "WORKTREE_PATH=$worktree_path"
    echo "WORKTREE_BRANCH=$branch_name"
    echo "STATUS=exists"
    exit 0
  fi

  # Create branch from base (stdout→stderr to keep eval-safe output)
  GIT_DIR=.bare git branch "$branch_name" "$base_branch" >&2

  # Add worktree (stdout→stderr to keep eval-safe output)
  GIT_DIR=.bare git worktree add "$worktree_path" "$branch_name" >&2

  echo "WORKTREE_PATH=$worktree_path"
  echo "WORKTREE_BRANCH=$branch_name"
  echo "STATUS=created"
}

cmd_merge() {
  local phase="${1:?Usage: manage-worktree.sh merge <phase> <plan> <base-branch> <merge-dir>}"
  local plan="${2:?Usage: manage-worktree.sh merge <phase> <plan> <base-branch> <merge-dir>}"
  local base_branch="${3:?Usage: manage-worktree.sh merge <phase> <plan> <base-branch> <merge-dir>}"
  local merge_target_dir="${4:?Usage: manage-worktree.sh merge <phase> <plan> <base-branch> <merge-dir>}"

  local branch_name="plan/${phase}-${plan}"
  local worktree_path
  worktree_path="$(pwd)/plan-${phase}-${plan}"

  # Verify worktree exists
  if [ ! -d "$worktree_path" ]; then
    echo "Error: No worktree at $worktree_path" >&2
    exit 1
  fi

  # Check for uncommitted changes
  if [ -n "$(git -C "$worktree_path" status --porcelain)" ]; then
    echo "Error: Worktree has uncommitted changes. Commit or stash first." >&2
    exit 1
  fi

  # Validate merge target directory exists
  if [ ! -d "$merge_target_dir" ]; then
    echo "Error: Merge target directory $merge_target_dir not found" >&2
    exit 1
  fi

  # Switch to base branch in merge target worktree (stdout→stderr to keep eval-safe output)
  git -C "$merge_target_dir" checkout "$base_branch" >&2

  # Remove untracked files in merge target that exist in the incoming plan branch.
  # Prevents "untracked working tree files would be overwritten by merge" errors
  # (e.g., package-lock.json generated by npm install between plan merges).
  local incoming_files
  incoming_files=$(GIT_DIR=.bare git diff --name-only "$base_branch" "$branch_name" 2>/dev/null || true)
  if [ -n "$incoming_files" ]; then
    while IFS= read -r file; do
      if [ -f "$merge_target_dir/$file" ] && ! git -C "$merge_target_dir" ls-files --error-unmatch "$file" &>/dev/null 2>&1; then
        rm -f "$merge_target_dir/$file"
        echo "Removed untracked file before merge: $file" >&2
      fi
    done <<< "$incoming_files"
  fi

  # Merge plan branch into base (fast-forward preferred, no editor for merge commit).
  # -X theirs auto-resolves content conflicts in favor of the plan branch
  # (plan agent has the most current STATE.md and other planning files).
  if ! git -C "$merge_target_dir" merge "$branch_name" --no-edit -X theirs >&2; then
    echo "Error: Merge conflict. Resolve manually in $merge_target_dir/ worktree." >&2
    echo "  cd $merge_target_dir && git merge --abort  # to abort" >&2
    echo "  cd $merge_target_dir && git mergetool      # to resolve" >&2
    exit 1
  fi

  # Remove worktree (stdout→stderr to keep eval-safe output)
  GIT_DIR=.bare git worktree remove "$worktree_path" >&2

  # Delete plan branch (force: plan merged into phase branch, not main, so -d thinks it's unmerged)
  GIT_DIR=.bare git branch -D "$branch_name" >&2

  echo "MERGED=true"
  echo "BASE_BRANCH=$base_branch"
  echo "STATUS=merged"
}

cmd_cleanup_phase() {
  local workspace_dir="${1:?Usage: manage-worktree.sh cleanup-phase <workspace-dir> <branch>}"
  local phase_branch="${2:?Usage: manage-worktree.sh cleanup-phase <workspace-dir> <branch>}"

  if [ ! -d "$workspace_dir" ]; then
    echo "Error: Workspace directory $workspace_dir not found" >&2
    exit 1
  fi

  # Check for uncommitted changes
  if [ -n "$(git -C "$workspace_dir" status --porcelain)" ]; then
    echo "Error: Workspace has uncommitted changes. Commit or stash first." >&2
    exit 1
  fi

  # Detect default branch
  local default_branch
  default_branch=$(GIT_DIR=.bare git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")
  # Fallback: check if main exists, else master
  if ! GIT_DIR=.bare git show-ref --verify --quiet "refs/heads/$default_branch" 2>/dev/null; then
    if GIT_DIR=.bare git show-ref --verify --quiet "refs/heads/main" 2>/dev/null; then
      default_branch="main"
    elif GIT_DIR=.bare git show-ref --verify --quiet "refs/heads/master" 2>/dev/null; then
      default_branch="master"
    fi
  fi

  # Switch workspace back to a workspace-base branch tracking the default branch.
  # Cannot checkout the default branch directly (main/ worktree already has it checked out).
  local workspace_branch="workspace-base"
  if GIT_DIR=.bare git show-ref --verify --quiet "refs/heads/$workspace_branch"; then
    # Reset workspace-base to match current default branch
    git -C "$workspace_dir" checkout "$workspace_branch" >&2
    git -C "$workspace_dir" reset --hard "$default_branch" >&2
  else
    git -C "$workspace_dir" checkout -b "$workspace_branch" "$default_branch" >&2
  fi

  # Delete phase branch
  GIT_DIR=.bare git branch -d "$phase_branch" >&2

  echo "CLEANED=true"
  echo "STATUS=cleaned"
}

cmd_list() {
  local count=0
  local output=""

  # Parse porcelain worktree list
  local current_path=""
  local current_branch=""

  while IFS= read -r line; do
    if [[ "$line" =~ ^worktree\ (.+) ]]; then
      current_path="${BASH_REMATCH[1]}"
    elif [[ "$line" =~ ^branch\ refs/heads/(.+) ]]; then
      current_branch="${BASH_REMATCH[1]}"
    elif [ -z "$line" ]; then
      # End of worktree entry; check if it matches plan-* pattern
      local dir_name
      dir_name=$(basename "$current_path")
      if [[ "$dir_name" =~ ^plan-([0-9]+)-([0-9]+)$ ]]; then
        local phase="${BASH_REMATCH[1]}"
        local plan="${BASH_REMATCH[2]}"
        output+="${dir_name}  ${current_branch}  phase=${phase} plan=${plan}"$'\n'
        count=$((count + 1))
      fi
      current_path=""
      current_branch=""
    fi
  done < <(GIT_DIR=.bare git worktree list --porcelain; echo "")

  echo "WORKTREE_COUNT=$count"
  if [ -n "$output" ]; then
    printf "%s" "$output"
  fi
}

# --- Main ---

SUBCOMMAND="${1:-}"

if [ -z "$SUBCOMMAND" ]; then
  echo "Usage: manage-worktree.sh <subcommand> [args]"
  echo ""
  echo "Subcommands:"
  echo "  create <phase> <plan> <base-branch>              — Create worktree for a plan"
  echo "  merge  <phase> <plan> <base-branch> <merge-dir>  — Merge plan branch and remove worktree"
  echo "  cleanup-phase <workspace-dir> <branch>            — Switch workspace back to workspace-base, delete phase branch"
  echo "  list                                              — List active plan worktrees"
  exit 1
fi

check_preconditions

shift
case "$SUBCOMMAND" in
  create)        cmd_create "$@" ;;
  merge)         cmd_merge "$@" ;;
  cleanup-phase) cmd_cleanup_phase "$@" ;;
  list)          cmd_list "$@" ;;
  *)
    echo "Error: Unknown subcommand '$SUBCOMMAND'" >&2
    echo "Usage: manage-worktree.sh <create|merge|cleanup-phase|list> [args]" >&2
    exit 1
    ;;
esac
